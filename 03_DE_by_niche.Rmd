---
title:  "Differential expression - Niches"
output: html_notebook
---




## Generate niches

<niche code>



```{r}
plotSpatialFeature(sfe.sample,'celltype_subset', colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```
```{r}
plotSpatialFeature(sfe.sample, "niche",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```
```{r}
plotSpatialFeature(sfe.sample2, "niche",colGeometryName = "cellSeg") + # Choose this one
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```

<niche composition>


```{r}


## Celltype proportions
celltype_summary_table<- colData(sfe) %>% as_tibble() %>%
  group_by(celltype_subset, niche ) %>%
  summarise(n_cells = n())

ggplot(celltype_summary_table, aes(fill=celltype_subset, y=n_cells, x=niche) )+
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Celltype composition")


```


niche spread across samples



```{r}


## Celltype proportions
celltype_summary_table<- colData(sfe) %>% as_tibble() %>%
  group_by(tissue_sample, niche ) %>%
  summarise(n_cells = n())

ggplot(celltype_summary_table, aes(fill=niche, y=n_cells, x=tissue_sample) )+
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Niche composition by sample")


```




## Pool samples into pseudobulk

Build pseudobulk (precomputed)
```{r eval=FALSE}
# DO NOT RUN
sfe$pdb_sample <- paste0(sfe$tissue_sample, '_', sfe$niche)
se.pdb <- aggregateAcrossCells(sfe, ids=sfe$pdb_sample,
                               BPPARAM = MulticoreParam(workers=4)  )
```

Load pseudobulk
```{r}
se.pdb <- readRDS(spe_pseudobulk_by_niche_file)
```




## Filter to a minimum num cells per pool

How many cell per pool?
```{r}
DT::datatable(data.frame(colData(se.pdb))[,c('pdb_sample','individual_code','tissue_sample','niche','ncells')])
```


```{r}
# What is the minimum accepptable number of cells in a pool?

min_cells_per_pdbsample <- 100

ggplot(colData(se.pdb), aes(x=ncells, col=niche)) +
  geom_density() +
  geom_vline(xintercept=min_cells_per_pdbsample, lty=3) +
  geom_rug() +
  scale_x_log10() +
  theme_bw() +
  ggtitle("How many cells per pseduobulk sample?")

```

Apply filter
```{r}
# Filter on minimum number of cells per pdb group
# (ncells column was added by aggregateAcrossCells)
se.pdb <- se.pdb[,se.pdb$ncells >= min_cells_per_pdbsample]
```





## Differential expression

```{r}

# Pull out the pseudoboulk counts matrix for passed samples
pseudobulk_counts_matrix <- counts(se.pdb)
# And the corresponding annotations
pseudobulk_anno_table    <- as_tibble(colData(se.pdb)[,c('pdb_sample','group', 'tissue_sample', 'niche', 'ncells')]) # + any other experimental factors


# Build a table of each contrast we might want to do. 
contrasts_wanted <- bind_cols(
  A= c("CD"), # First terms
  B= c("HC")  # Second terms (usually control)
)


```

```{r}
table(pseudobulk_anno_table$niche, pseudobulk_anno_table$group)
```



```{r}
# Empty list to collect results
de_result_list <- list()

## Cycle through each niche
for (the_niche in levels(se.pdb$niche)) {

  # Subset pseudobulk object to one niche
  se.pdb.this <- se.pdb[,se.pdb$niche == the_niche]
  
  # And pull out the annotation and counts
  anno_table.this   <- as.tibble(colData(se.pdb.this))
  count_matrix.this <- counts(se.pdb.this)

  
  ## Check for sufficient replicates ##
  # To do any calculations, we need at least 2 pseudobulk groups per contrast.
  # there are plenty in this experiemnt, but with less replicates and rare cell types
  # its very common to have to skip some contrats for some niches.

  # skip clusters with no samples after filtering
  if( nrow(anno_table.this) < 1 ) {next}
  
  # Count how many bio samples per group (only need one fov to count it)
  biosample_per_group <- anno_table.this %>% 
    select(group, tissue_sample) %>%
    pull(group) %>% # pull out group column, one entry per tissue sample
    table() # count how many

  # Are there enough Biological smples to consider the contrast?
  min_biosample_per_group <- 2
  enough_biosamples <- 
    (unname(biosample_per_group[contrasts_wanted$A]) >= min_biosample_per_group) &
    (unname(biosample_per_group[contrasts_wanted$B]) >= min_biosample_per_group)
    
  # Make a new table with contrasts that we have enough biosamples for.
  contrasts_to_test <- contrasts_wanted[enough_biosamples,]
  
  # Skip if no contrasts are testable
  if (nrow(contrasts_to_test) == 0) {next}
  
  ## Setup model
  
  # Setup objects for limma
  dge <- DGEList(count_matrix.this)
  dge <- calcNormFactors(dge)
  
  # Build model
  group           <- anno_table.this$group

  # Model design 
  # Add other experimental factors here 
  # ~0 + group
  # ~0 + group + individual
  # ~0 + group + individual + slide
  design    <- model.matrix( ~0 + group)
  
  # Run Voom
  vm  <- voom(dge, design = design, plot = FALSE)
  
  # Adding dupliate correlation to use individual fovs, rather than pooled per biosample
  fit     <- lmFit(vm, design) 

  # Define and fit contrasts and run ebayes
  # Doing this in an automated way so we can include/exvlude contrasts where 
  # there are / arenot enough replicates available. 
  # That's why generatgin a string .
  contrast_str_list <- paste0("group",contrasts_to_test$A,"-","group",contrasts_to_test$B)
  
  contrasts <- makeContrasts(contrasts=contrast_str_list,
                           levels=coef(fit))
  
  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit)

  
  
  ## Loop through contrasts.
  # You ccan run multiple contrasts at onces, but doing it this way allows us
  # to skip individual contrasts within a niche.
  for ( the_coef in colnames(contrasts) ) {
    # Make a version of the coeffient name that doesn't include a '-', or the 
    # factor name (group)
    # Life is easier without special characters
    # groupUC-groupHC => UCvHC
    contrast_name <- gsub("group","", gsub("-","v",the_coef))
    
    de_result.this <- topTable(fit, n = Inf, adjust.method = "BH", coef = the_coef) %>%
      rownames_to_column("target") %>%
      mutate(contrast=contrast_name,
             contrast_group="pairwise",
             niche=the_niche) %>%
      select(niche,contrast_group, contrast,target,everything()) %>%
      arrange(P.Value)
    
      # build a unique name for this result by adding
      # <niche>_<A>v<B>
      de_result_list[[paste(the_niche, contrast_name, sep="_")]] <- de_result.this
    
  }

}
  
# Join together results for all niches, and pull out those with a singificant adjusted p-value
de_results_all.niche <- bind_rows(de_result_list)
de_results_sig.niche <- filter(de_results_all.niche, adj.P.Val < 0.05)



```

```{r}
DT::datatable(de_results_sig.niche)
```


