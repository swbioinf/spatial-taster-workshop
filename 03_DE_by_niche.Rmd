---
title: "Differential expression - Niches"
output:
  html_document:
    toc: true
    df_print: paged
---

```{r results='hide', echo=FALSE, warning=FALSE, message=FALSE}
#Ignore this chunk, it is only to run the setup Rmarkdown when knitting 
building_htmls <- ! interactive()
if (building_htmls ) {
   source(knitr::purl("00_Setup.Rmd", quiet=TRUE))
}
```

**What is the difference between Crohns Disease and healthy samples in different regions of the tissue?**


There are clear 'regions' in the tissue, e.g. a lymphoid region full of T cells and B cells. Or the very outer layer of epithelial, or the basal layer or stromal cells. We can identify and test for differences within these 'niches'. 

```{r}
plotSpatialFeature(sfe.sample.HC,'celltype_subset', colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```


## Generate niches

We can use 'Banksy' to define niches. Banksy doesn't use use celltypes at all; It uses 3 pieces of information; each cells gene expression, its surrounding gene expression and a 'azimuthal gabor filter' (AGF) to capture the surrounding gene expression gradient - see Figure 1 https://www.nature.com/articles/s41588-024-01664-3 

Again, this takes some time to run. The results are already loaded in the sfe object. 

```{r eval=FALSE}

## DO NOT RUN ##

# Lamda defines how much Banksy should consider the gene expression surrounding a cell
# O uses only *this* cell, and 0.8 recommended for domain  (niche) finding
lamdas      <- c(0.6) 

# Resolution of clustering step 
# Higher values = more niches.
resolutions <- c(0.3, 0.5)

# try to limit to just hvgs
hvgs <- rownames(rowData(sfe))[rowData(sfe)$hvg]
sfe.hvg <- sfe[hvgs,]
sfe.hvg$tissue_sample<- droplevels(sfe.hvg$tissue_sample)

#split by sample
get_one_sample <- function(the_sample){sfe.hvg[,sfe.hvg$tissue_sample == the_sample]}
sfe.list <- lapply(FUN=get_one_sample, X=levels(sfe.hvg$tissue_sample))

# Get the underlying banksy computation
sfe.list <- lapply(sfe.list, computeBanksy, assay_name = 'logcounts', k_geom = k_geom)
sfe.merged <- do.call(cbind, sfe.list)
sfe.merged <- Banksy::runBanksyPCA(sfe.merged, lambda = lamdas, npcs = npcs, group='tissue_sample', seed=12)
sfe.merged <- Banksy::clusterBanksy(sfe.merged, lambda = lamdas, npcs = npcs, resolution = resolutions, seed=12)

niches_table <- colData(sfe.merged)
niche_lookup <- setNames(niches_table$clust_M0_lam0.6_k50_res0.5, nm=as.character( niches_table$cell ))
niche_lookup2 <- setNames(niches_table$clust_M0_lam0.6_k50_res0.3, nm=as.character( niches_table$cell ))
sfe$clust_M0_lam0.6_k50_res0.5 <- niche_lookup[as.character(sfe$cell)]
sfe$clust_M0_lam0.6_k50_res0.3 <- niche_lookup2[as.character(sfe$cell)]
sfe$niche <- factor(paste0('n', as.character(sfe$clust_M0_lam0.6_k50_res0.3)),
                     levels=paste0('n',levels(sfe$clust_M0_lam0.6_k50_res0.3)))

```

```{r}
head(colData(sfe), n=100) %>% as_tibble() %>% 
  select(cell, tissue_sample, celltype_subset, clust_M0_lam0.6_k50_res0.5, clust_M0_lam0.6_k50_res0.3, niche )
```



```{r}
plotSpatialFeature(sfe.sample.HC, "niche",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```


Compare with one of the Crohn's samples.

```{r}
plotSpatialFeature(sfe.sample.CD,'celltype_subset', colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```

```{r}
plotSpatialFeature(sfe.sample.CD, "niche",colGeometryName = "cellSeg") + # Choose this one
  theme(legend.title=element_blank()) +
  ggtitle(sample)
```



### Explore niches 


What celltypes make up the niches?

Can see that;

* Niche 7 is almost entirely epithelia along the outer edge. 
* Niche 2 is the epithelia in the epithelial 'crypt' structures in the lamina propria.
* Niche 6 captures the lymphoid regions seen in in HC_a, full of T cells and plasma cells

```{r}
## Celltype proportions
celltype_summary_table<- colData(sfe) %>% as_tibble() %>%
  group_by(celltype_subset, niche ) %>%
  summarise(n_cells = n())

ggplot(celltype_summary_table, aes(fill=celltype_subset, y=n_cells, x=niche) )+
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Celltype composition")
```

Likewise, its helpful to see what their proportions are across different sample. 
This can be quite variable - particularly when we're working on a particularly 
small region of each sample!

```{r}
## Celltype proportions
celltype_summary_table<- colData(sfe) %>% as_tibble() %>%
  group_by(tissue_sample, niche ) %>%
  summarise(n_cells = n())

ggplot(celltype_summary_table, aes(fill=niche, y=n_cells, x=tissue_sample) )+
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  coord_flip() +
  theme(legend.position = "bottom") +
  scale_y_continuous(expand = c(0,0)) +
  ggtitle( "Niche composition by sample")


```




## Pool samples into pseudobulk

So again - build another pseudobulk, this time on the niche level. 

Build pseudobulk (precomputed)
```{r eval=FALSE}
# DO NOT RUN
sfe$pdb_sample <- paste0(sfe$tissue_sample, '_', sfe$niche)
se.pdb <- aggregateAcrossCells(sfe, ids=sfe$pdb_sample,
                               BPPARAM = MulticoreParam(workers=4)  )
```

Load pseudobulk
```{r}
se.pdb <- readRDS(spe_pseudobulk_by_niche_file)
```

```{r}
counts(se.pdb)[1:5,1:5]
```

## Filter to a minimum num cells per pool

How many cell per pool?
```{r}
DT::datatable(data.frame(colData(se.pdb))[,c('pdb_sample','individual_code','tissue_sample','niche','ncells')])
```


```{r}
# What is the minimum acceptable number of cells in a pool?

min_cells_per_pdbsample <- 100

ggplot(colData(se.pdb), aes(x=ncells, col=niche)) +
  geom_density() +
  geom_vline(xintercept=min_cells_per_pdbsample, lty=3) +
  geom_rug() +
  scale_x_log10() +
  theme_bw() +
  ggtitle("How many cells per pseduobulk sample?")

```

Again, apply filter.

```{r}
# Filter on minimum number of cells per pdb group
# (ncells column was added by aggregateAcrossCells)
se.pdb <- se.pdb[,se.pdb$ncells >= min_cells_per_pdbsample]
```


## Differential expression

Differential expression calculated exactly as per celltype, just with niche.

```{r}

# Pull out the pseudobulk counts matrix for passed samples
pseudobulk_counts_matrix <- counts(se.pdb)
# And the corresponding annotations
pseudobulk_anno_table    <- as_tibble(colData(se.pdb)[,c('pdb_sample','group', 'tissue_sample', 'niche', 'ncells')]) # + any other experimental factors


# Build a table of each contrast we might want to do. 
contrasts_wanted <- bind_cols(
  A= c("CD"), # First terms
  B= c("HC")  # Second terms (usually control)
)


```

We won't be able to test niches 6 or 8. But the below code will test for the number of available conditions per side, and skip them automatically.

```{r}
table(pseudobulk_anno_table$niche, pseudobulk_anno_table$group)
```

```{r}
# Empty list to collect results
de_result_list <- list()

## Cycle through each niche
for (the_niche in levels(se.pdb$niche)) {

  # Subset pseudobulk object to one niche
  se.pdb.this <- se.pdb[,se.pdb$niche == the_niche]
  
  # And pull out the annotation and counts
  anno_table.this   <- as.tibble(colData(se.pdb.this))
  count_matrix.this <- counts(se.pdb.this)

  
  ## Check for sufficient replicates ##
  # To do any calculations, we need at least 2 pseudobulk groups per contrast.
  # there are plenty in this experiment, but with less replicates and rare cell types
  # its very common to have to skip some contrast for some niches.

  # skip clusters with no samples after filtering
  if( nrow(anno_table.this) < 1 ) {next}
  
  # Count how many bio samples per group (only need one fov to count it)
  biosample_per_group <- anno_table.this %>% 
    select(group, tissue_sample) %>%
    pull(group) %>% # pull out group column, one entry per tissue sample
    table() # count how many

  # Are there enough Biological samples to consider the contrast?
  min_biosample_per_group <- 2
  enough_biosamples <- 
    (unname(biosample_per_group[contrasts_wanted$A]) >= min_biosample_per_group) &
    (unname(biosample_per_group[contrasts_wanted$B]) >= min_biosample_per_group)
    
  # Make a new table with contrasts that we have enough biosamples for.
  contrasts_to_test <- contrasts_wanted[enough_biosamples,]
  
  # Skip if no contrasts are testable
  if (nrow(contrasts_to_test) == 0) {next}
  
  ## Setup model
  
  # Setup objects for limma
  dge <- DGEList(count_matrix.this)
  dge <- calcNormFactors(dge)
  
  # Build model
  group           <- anno_table.this$group

  # Model design 
  # Add other experimental factors here 
  # ~0 + group
  # ~0 + group + individual
  # ~0 + group + individual + slide
  design    <- model.matrix( ~0 + group)
  
  # Run Voom
  vm  <- voom(dge, design = design, plot = FALSE)
  
  # Fit model
  fit     <- lmFit(vm, design) 

  # Define and fit contrasts and run ebayes
  # Doing this in an automated way so we can include/exclude contrasts where 
  # there are / aren't enough replicates available. 
  # That's why generating a string .
  contrast_str_list <- paste0("group",contrasts_to_test$A,"-","group",contrasts_to_test$B)
  
  contrasts <- makeContrasts(contrasts=contrast_str_list,
                           levels=coef(fit))
  
  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit)

  
  
  ## Loop through contrasts.
  # You can run multiple contrasts at once, but doing it this way allows us
  # to skip individual contrasts within a niche.
  for ( the_coef in colnames(contrasts) ) {
    # Make a version of the coefficient name that doesn't include a '-', or the 
    # factor name (group)
    # Life is easier without special characters
    # groupUC-groupHC => UCvHC
    contrast_name <- gsub("group","", gsub("-","v",the_coef))
    
    de_result.this <- topTable(fit, n = Inf, adjust.method = "BH", coef = the_coef) %>%
      rownames_to_column("target") %>%
      mutate(contrast=contrast_name,
             contrast_group="pairwise",
             niche=the_niche) %>%
      select(niche,contrast_group, contrast,target,everything()) %>%
      arrange(P.Value)
    
      # build a unique name for this result by adding
      # <niche>_<A>v<B>
      de_result_list[[paste(the_niche, contrast_name, sep="_")]] <- de_result.this
    
  }

}
  
# Join together results for all niches, and pull out those with a significant adjusted p-value
de_results_all.niche <- bind_rows(de_result_list)
de_results_sig.niche <- filter(de_results_all.niche, adj.P.Val < 0.05)



```

```{r}
DT::datatable(de_results_sig.niche)
```


## Evaluate DE (by regional niche) genes

Again, make some normalised expression just for plotting. 

```{r}
# Get some normalised values, purely for plotting.
# (can't use logged counts because the sizes are so dramatically different!)
dge <- DGEList(counts(se.pdb))
dge <- calcNormFactors(dge)
norm_counts <- cpm(dge)

# Store normalised log2 scale expression in 
assay(se.pdb, "logcounts") <- log2(norm_counts)
```


### IGHG1 and IGHG2

IGHG1 and IGHG2 (heavy chain immunoglobulins) are behaving very similarly, but the change seems to be fairly global.
```{r}
p1 <- plotExpression(se.pdb, "IGHG2", x="group", colour_by = "group",
               other_fields = "niche") + 
  ggtitle("IGHG2") + 
  facet_wrap(~niche)
p2 <- plotExpression(se.pdb, "IGHG1", x="group", colour_by = "group",
               other_fields = "niche") + 
  ggtitle("IGHG1") + 
  facet_wrap(~niche)

p1 + p2 
```



Just showing IGHG2; Suddenly Niche 1 makes sense!

```{r}
p1 <- plotSpatialFeature(sfe.sample.HC, "IGHG2",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample) +
  ggtitle("IGHG2 - HC_b")
p2 <- plotSpatialFeature(sfe.sample.CD, "IGHG2",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample) +
    ggtitle("IGHG2 - CD_a")

p1 / p2
```


### WNT2B 

Could a lack of WNT2B be relevant? https://pubmed.ncbi.nlm.nih.gov/38697357/

```{r}
plotExpression(se.pdb, "WNT2B", x="group", colour_by = "group",
               other_fields = "niche") + 
  ggtitle("WNT2B") + 
  facet_wrap(~niche)
```


```{r}
p1 <- plotSpatialFeature(sfe.sample.HC, "WNT2B",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample) +
  ggtitle("WNT2B - HC_b")
p2 <- plotSpatialFeature(sfe.sample.CD, "WNT2B",colGeometryName = "cellSeg") + 
  theme(legend.title=element_blank()) +
  ggtitle(sample) +
    ggtitle("WNT2B - CD_a")

p1 / p2
```

