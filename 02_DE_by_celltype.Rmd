---
title: "Differential expression - celltypes"
output:
  html_document:
    toc: true
    df_print: paged
---

```{r results='hide', echo=FALSE, warning=FALSE, message=FALSE}
#Ignore this chunk, it is only to run the setup Rmarkdown when knitting 
building_htmls <- ! interactive()
if (building_htmls ) {
   source(knitr::purl("00_Setup.Rmd", quiet=TRUE))
}
```


**What is the difference between Crohns Disease and healthy samples; in terms of gene expression within each cell type?**


This is essentially the same thing as a single cell experiment. For a review of approaches see; [Soneson & Robinson 2018](https://www.nature.com/articles/nmeth.4612)

We're going to use a pseudobulk approach; summing up all cells within a group, and treating it more like a bulk RNAseq experiment. 

For a more detailed walkthrough of this test, see (spatial sampler differential expression by celltype HowTo)[https://swbioinf.github.io/spatialsnippets/e_DEPseudobulkSampleLevel_insitu_sfe.html]


## Pool samples into pseudobulk


We need to created a cell annotation for the pseudobulk grouping in our analysis. We can do this by concatenating the tissue sample ID with the celltype; calling this column pdb_sample here.

Now use the PseudobulkExpression() function to sum up each gene’s gene expression across each pdb_sample.

This will build a SummarisedExperiment object at the ‘sample+celltype’ level’. Which contains one entry per group, containing the sum of copies of the gene in all cells within the grouping.


This can take a while to run - So load one that's already been preprocessed


NB: We might consider applying an additional filter for number of minimum counts per cell here (particularly sice we don't need to maintain spatial information), but this data has already been filtered.



```{r eval=FALSE}
## DO NOT RUN ##
sfe$pdb_sample <- paste0(sfe$tissue_sample, '_', sfe$celltype_subset)
se.pdb <- aggregateAcrossCells(sfe, ids=sfe$pdb_sample,
                               BPPARAM = MulticoreParam(workers=4)  )
```

Load pseudobulk
```{r}
se.pdb <- readRDS(spe_pseudobulk_by_celltype_file)
```

The counts per cell look like this. Many zeros.

```{r}
counts(sfe)[1:10,1:8]
```

But the counts per pseudobulk sample look like this:
```{r}
counts(se.pdb)[1:10,1:8]
```

## Filter to a minimum num cells per pool


There's going to be cases where a given sample doesn't have enough cells to reasonably test. We will pick a threshold for 'minimum cells per pseudobulk sample' based on the distribution of the data. A pool of just 6 cells would be way too small!


```{r}
DT::datatable(data.frame(colData(se.pdb))[,c('pdb_sample','individual_code','tissue_sample','ncells')])
```


100 is a decent threshold for this data. We could consider 200, but we would start to loose more of the T-cells, with fewer overall.
```{r}
# What is the minimum accepptable number of cells in a pool?
min_cells_per_pdbsample <- 100

ggplot(colData(se.pdb), aes(x=ncells, col=celltype_subset)) +
  geom_density() +
  geom_vline(xintercept=min_cells_per_pdbsample, lty=3) +
  geom_rug() +
  scale_x_log10() +
  theme_bw() +
  ggtitle("How many cells per pseduobulk sample?")

```

Apply filter
```{r}
# Filter on minimum number of cells per pdb group
# (ncells column was added by aggregateAcrossCells)
se.pdb <- se.pdb[,se.pdb$ncells >= min_cells_per_pdbsample]
```


## Differential expression


We pull out the counts data, and corresponding psuedobulk annotation. And build a table of the contrasts we want to test - here there is only one - 'CD-HC'; Crohns disease vs Healthy Controls.

```{r}
# Pull out the pseudoboulk counts matrix for passed samples
pseudobulk_counts_matrix <- counts(se.pdb)
# And the corresponding annotations
pseudobulk_anno_table    <- as_tibble(colData(se.pdb)[,c('pdb_sample','group', 'tissue_sample', 'celltype_subset', 'ncells')]) # + any other experimental factors

# Build a table of each contrast we might want to do. 
contrasts_wanted <- bind_cols(
  A= c("CD"), # First terms
  B= c("HC")  # Second terms (usually control)
)

```


This secion of code will test for differential expression, looping through each celltype.
 
1) Subset the counts and annotation to only that celltype
2) And then, for each contrast we want to test (Which is only 1)
   a. Check if there are enough biological replicates to test (ie. at least 2vs2)
   b. Build a DGE list object with edgeR for testing
   c. Define the design matrix, here simply: ~0 + group
   d. Use Voom and Limma to test specificed contrasts
   e. Pull out a results table, annotated with celltype and contrast tested
   f. Record it
3) Merge together all results tables

```{r}
# Empty list to collect results
de_result_list <- list()

## Cycle through each celltype
for (the_celltype in levels(se.pdb$celltype_subset)) {

  # Subset pseudobulk object to one celltype
  se.pdb.this <- se.pdb[,se.pdb$celltype_subset == the_celltype]
  
  # And pull out the annotation and counts
  anno_table.this   <- as.tibble(colData(se.pdb.this))
  count_matrix.this <- counts(se.pdb.this)

  
  ## Check for sufficient replicates ##
  # To do any calculations, we need at least 2 pseudobulk groups per contrast.
  # there are plenty in this experiemnt, but with less replicates and rare cell types
  # its very common to have to skip some contrats for some celltypes.

  # skip clusters with no samples after filtering
  if( nrow(anno_table.this) < 1 ) {next}
  
  # Count how many bio samples per group (only need one fov to count it)
  biosample_per_group <- anno_table.this %>% 
    select(group, tissue_sample) %>%
    pull(group) %>% # pull out group column, one entry per tissue sample
    table() # count how many

  # Are there enough Biological smples to consider the contrast?
  min_biosample_per_group <- 2
  enough_biosamples <- 
    (unname(biosample_per_group[contrasts_wanted$A]) >= min_biosample_per_group) &
    (unname(biosample_per_group[contrasts_wanted$B]) >= min_biosample_per_group)
    
  # Make a new table with contrasts that we have enough biosamples for.
  contrasts_to_test <- contrasts_wanted[enough_biosamples,]
  
  
  
  ## Setup model
  
  # Setup objects for limma
  dge <- DGEList(count_matrix.this)
  dge <- calcNormFactors(dge)
  
  # Build model
  group           <- anno_table.this$group

  # CUSTOMISE:
  # Model design 
  # Add other experimental factors here 
  # ~0 + group
  # ~0 + group + individual
  # ~0 + group + individual + slide
  design    <- model.matrix( ~0 + group)
  
  # Run Voom
  vm  <- voom(dge, design = design, plot = FALSE)
  
  # Adding dupliate correlation to use individual fovs, rather than pooled per biosample
  fit     <- lmFit(vm, design) 

  # Define and fit contrasts and run ebayes
  # Doing this in an automated way so we can include/exvlude contrasts where 
  # there are / arenot enough replicates available. 
  # That's why generatgin a string .
  contrast_str_list <- paste0("group",contrasts_to_test$A,"-","group",contrasts_to_test$B)
  
  contrasts <- makeContrasts(contrasts=contrast_str_list,
                           levels=coef(fit))
  
  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit)

  
  
  ## Loop through contrasts.
  # You ccan run multiple contrasts at onces, but doing it this way allows us
  # to skip individual contrasts within a celltype.
  for ( the_coef in colnames(contrasts) ) {
    # Make a version of the coeffient name that doesn't include a '-', or the 
    # factor name (group)
    # Life is easier without special characters
    # groupUC-groupHC => UCvHC
    contrast_name <- gsub("group","", gsub("-","v",the_coef))
    
    de_result.this <- topTable(fit, n = Inf, adjust.method = "BH", coef = the_coef) %>%
      rownames_to_column("target") %>%
      mutate(contrast=contrast_name,
             contrast_group="pairwise",
             celltype=the_celltype) %>%
      select(celltype,contrast_group, contrast,target,everything()) %>%
      arrange(P.Value)
    
      # build a unique name for this result by adding
      # <celltype>_<A>v<B>
      de_result_list[[paste(the_celltype, contrast_name, sep="_")]] <- de_result.this
    
  }

}
  
# Join together results for all celltypes, and pull out those with a singificant adjusted p-value
de_results_all.celltype <- bind_rows(de_result_list)
de_results_sig.celltype <- filter(de_results_all.celltype, adj.P.Val < 0.05)



```


The significant results:

```{r}
DT::datatable(de_results_sig.celltype)
```


## Evaluate DE (by celltype) genes

We can plot each cell's expression, but most counts are zero. This is hard to read (and slow).

```{r}
plotExpression(sfe, "SELENOP", x="group", colour_by = "group",
               other_fields = "celltype_subset") + 
 facet_wrap(~celltype_subset)
```



The differential expression used counts data, but we can still calculate some normalised expression at the pseudobulk level. 
```{r}
# Get some normalised values, purely for plotting.
# (can't use logged counts because the sizes are so dramatically different!)
dge <- DGEList(counts(se.pdb))
dge <- calcNormFactors(dge)
norm_counts <- cpm(dge)

# Store normalised log2 scale expression in 
assay(se.pdb, "logcounts") <- log2(norm_counts)
```


Here we can see the expression per biological sample.

```{r}
plotExpression(se.pdb, "SELENOP", x="group", colour_by = "group",
               other_fields = "celltype_subset") + 
 facet_wrap(~celltype_subset)
```



